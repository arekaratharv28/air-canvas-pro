<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Protocol: AIR_CANVAS_V6</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body { background-color: #050505; overflow: hidden; font-family: monospace; }
        .mirror { transform: scaleX(-1); }
        
        /* Layering System */
        #container { position: relative; width: 100vw; height: 100vh; }
        
        /* Layer 1: Video (Bottom) */
        #input_video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 0; opacity: 0.6; }
        
        /* Layer 2: Ink (Middle) - Stores the drawings */
        #ink_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; }
        
        /* Layer 3: Cursor (Top) - Shows the hand pointer */
        #cursor_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20; pointer-events: none; }
        
        .glass { background: rgba(0, 0, 0, 0.8); border: 1px solid rgba(0, 255, 0, 0.3); backdrop-filter: blur(4px); }
    </style>
</head>
<body class="text-white">

    <div class="absolute top-0 left-0 w-full p-2 z-50 pointer-events-none">
        <div class="glass p-2 rounded max-w-xs pointer-events-auto">
            <h1 class="text-green-400 font-bold">V6: LAYERED ENGINE</h1>
            <p id="debug-log" class="text-xs text-gray-300">SYSTEM INITIALIZING...</p>
        </div>
    </div>

    <div class="absolute bottom-6 left-0 w-full flex justify-center gap-4 z-50 pointer-events-auto">
        <input type="color" id="colorPicker" value="#00ffff" class="w-12 h-12 rounded-full border-2 border-white cursor-pointer bg-black" onchange="updateColor(this.value)">
        <button onclick="wipeInk()" class="bg-red-600 hover:bg-red-500 text-white px-6 py-2 rounded-full font-bold shadow-[0_0_15px_rgba(255,0,0,0.5)] transition">WIPE</button>
        <button onclick="saveArt()" class="bg-blue-600 hover:bg-blue-500 text-white px-6 py-2 rounded-full font-bold shadow-[0_0_15px_rgba(0,0,255,0.5)] transition">SAVE</button>
    </div>

    <div id="container">
        <video id="input_video" class="mirror" autoplay playsinline></video>
        <canvas id="ink_canvas" class="mirror"></canvas>
        <canvas id="cursor_canvas" class="mirror"></canvas>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const inkCanvas = document.getElementById('ink_canvas');
        const inkCtx = inkCanvas.getContext('2d');
        const cursorCanvas = document.getElementById('cursor_canvas');
        const cursorCtx = cursorCanvas.getContext('2d');
        const debugLog = document.getElementById('debug-log');
        
        // Resize Handler
        function resize() {
            inkCanvas.width = window.innerWidth;
            inkCanvas.height = window.innerHeight;
            cursorCanvas.width = window.innerWidth;
            cursorCanvas.height = window.innerHeight;
            // Setup Ink Context style
            inkCtx.lineCap = "round";
            inkCtx.lineJoin = "round";
        }
        window.addEventListener('resize', resize);
        resize();

        let globalColor = '#00ffff';
        let handStates = {}; 

        // CONFIGURATION
        const PINCH_THRESHOLD = 0.06; // < 0.06 = Draw
        const RELEASE_THRESHOLD = 0.08; // > 0.08 = Stop (Hysteresis)

        function distance(p1, p2) {
            return Math.hypot(p1.x - p2.x, p1.y - p2.y);
        }

        function onResults(results) {
            // CRITICAL FIX: We do NOT draw results.image onto inkCanvas.
            // We ONLY clear the cursor canvas so the cursor can move.
            cursorCtx.clearRect(0, 0, cursorCanvas.width, cursorCanvas.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                let debugMsg = "";

                results.multiHandLandmarks.forEach((landmarks, i) => {
                    if (!handStates[i]) handStates[i] = { isDrawing: false, lastPoint: null };
                    let state = handStates[i];

                    const thumbTip = landmarks[4];
                    const indexTip = landmarks[8];
                    
                    // 1. Calculate Pinch
                    const dist = distance(thumbTip, indexTip);
                    
                    // 2. Sticky Logic (Hysteresis)
                    if (!state.isDrawing && dist < PINCH_THRESHOLD) {
                        state.isDrawing = true;
                    } else if (state.isDrawing && dist > RELEASE_THRESHOLD) {
                        state.isDrawing = false;
                        state.lastPoint = null; // Lift pen
                    }

                    // 3. Status Text
                    const colorClass = state.isDrawing ? "text-green-400 font-bold" : "text-gray-400";
                    debugMsg += `<div class="${colorClass}">Hand ${i}: ${state.isDrawing ? "DRAWING" : "HOVER"} (${dist.toFixed(2)})</div>`;

                    // 4. Coordinates
                    const x = ((thumbTip.x + indexTip.x) / 2) * inkCanvas.width;
                    const y = ((thumbTip.y + indexTip.y) / 2) * inkCanvas.height;

                    // 5. Draw CURSOR (On Top Layer)
                    cursorCtx.beginPath();
                    cursorCtx.arc(x, y, state.isDrawing ? 5 : 10, 0, 2 * Math.PI);
                    cursorCtx.strokeStyle = "white";
                    cursorCtx.lineWidth = 2;
                    cursorCtx.stroke();
                    if (state.isDrawing) {
                        cursorCtx.fillStyle = globalColor;
                        cursorCtx.fill();
                    }

                    // 6. Draw INK (On Middle Layer - Persistent)
                    if (state.isDrawing) {
                        if (state.lastPoint) {
                            inkCtx.beginPath();
                            inkCtx.moveTo(state.lastPoint.x, state.lastPoint.y);
                            inkCtx.lineTo(x, y);
                            inkCtx.strokeStyle = globalColor;
                            inkCtx.lineWidth = 8; // Thick visible line
                            inkCtx.stroke();
                        }
                        state.lastPoint = {x, y};
                    }
                });
                debugLog.innerHTML = debugMsg;
            } else {
                debugLog.innerHTML = "NO HANDS DETECTED";
            }
        }

        function updateColor(val) { globalColor = val; }
        
        function wipeInk() { 
            // Only clear the Ink layer, not the video or cursor
            inkCtx.clearRect(0, 0, inkCanvas.width, inkCanvas.height);
            handStates = {};
        }

        function saveArt() {
            // To save, we must composite the Ink onto a white background (or transparent)
            const dataURL = inkCanvas.toDataURL('image/png');
            fetch('/upload', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ image: dataURL })
            });
            debugLog.innerHTML = "<span class='text-blue-400'>SAVED TO CLOUD!</span>";
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        // Optimized for fast tracking
        hands.setOptions({ maxNumHands: 4, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 1280, height: 720
        });
        camera.start();
    </script>
</body>
</html>